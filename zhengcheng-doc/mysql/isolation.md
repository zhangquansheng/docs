# MySQL事务的四个隔离级别

关键字：`脏读` `幻读`

| 序号  | 英文名   | 中文名  |  并发问题 |
| ------------ | ------------ | ------------ | ------------ |
| 1  |  read_uncommited | 读未提交  | 都有问题 |
| 2  | read_commited  |  读已提交/不可重复读 | 脏读(Dirty Read)  |
| 3  | repeatable_read  | 可重复读  | 幻读  |
| 4  |  serilizable |  序列化读 | 没有问题  |		

1. 脏读(Dirty Read)
   
   A事务读取B事务尚未提交的**更改数据(UPDATE)**，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。例如常见的取款事务和转账事务：

2. 幻读
   
   A事务读取B事务提交的**新增数据(INSERT)**,会引发幻读问题。幻读一般发生在计算统计数据的事务中，例如银行系统在同一个事务中两次统计存款账户的总金额，在两次统计中，刚好新增了一个存款账户，存入了100，这时候两次统计的总金额不一致。
 
## 数据库中的锁

1. 共享锁（又称为读锁和`S锁`）: 若`事务T`对数据`对象A`加上`S锁`，则`事务T`可以读`A`但不能修改`A`，其他事务只能再对`A`加`S锁`，而不能加`X锁`，直到`T`释放`A`上的`S锁`为止。
2. 排它锁（又称为写锁和`X锁`）: 若`事务T`对数据`对象A`加上`X锁`，则只允许`T`读取和修改`A`，其他任何事务都不能再对`A`加任何类型的锁，直到`T`释放`A`上的锁为止。

**通过锁来实现隔离,通过对事务的读写操作加锁情况的不同，划分出不同的事务隔离级别**