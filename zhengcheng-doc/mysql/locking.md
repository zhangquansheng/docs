# 锁

## Innodb存储引擎中的锁

### 锁的类型

`Innodb`存储引擎实现了如下两种标准的行级锁：
- 共享锁(`S Lock`)，允许事务读取一行数据，又称为读锁
- 排它锁(`X Lock`)，允许事务删除或者更新一行数据，又称为写锁、独占锁。

共享锁和排他锁的兼容性：

- | S | X
---|---|---
S | 兼容 | 不兼容 
X | 不兼容 |  不兼容

从表中可以发现`X锁`与任何的锁都不兼容，而`S锁`仅和`S锁`兼容。需要特别注意的是，`S锁`和`X锁`都是**行锁**，兼容是指对同一记录（row）锁的兼容性情况。

此外，`Innodb`存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，`Innodb`存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。

`Innodb`存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行（数据库->表->页->行记录）将被请求的锁类型。其支持两种意向锁：
- 意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁
- 意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁

由于`Innodb`存储引擎支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以后的任何请求。故表级意向锁与行级锁的兼容性如下表：

- | IS | IX | S | X
---|---|---|---|---
IS | 兼容 | 兼容 | 兼容 | 不兼容 
IX | 兼容 |  兼容 |  不兼容 |  不兼容
S | 兼容 |  不兼容 |  兼容|  不兼容
X | 不兼容 |  不兼容 |  不兼容 |  不兼容

### 一致性非锁定读

一致性非锁定读(consistent nonlocking read)是指`Innodb`存储引擎通过多版本控制(multi versioning)的方式来读取当前执行时间数据库中行的数据，如果读取的行正在执行DELETE或UPDATE操作，这是读取操作不会因此等待行上锁的释放。相反的，`Innodb`会去读取行的一个快照数据
![Innodb存储引擎的一致性的非锁定读](/img/mysql/c-nl-read.jpg)

上面展示了`Innodb`存储引擎一致性非锁定读。之所以称为**非锁定读**，因为不需要等待访问的行上`X锁`的释放。快照数据是指该行之前版本的数据，该实现是通过`undo`段来完成。而`undo`用来事务中的回滚数据，因此快照数据本身没有额外的开销，此外，读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改操作。

可以看到，非锁定读机制极大地提高了数据库的并发性，在`Innodb`存储引擎的默认设置下，这是默认的读写方式，即读不会占用和等待表上的锁。但是在不同的事务隔离级别下，读取的方式不同，并不是每个事务隔离级别下都是采用非锁定的一致性读，此外，即使使用非锁定的一致性读，但是对于快照数据的定义也各不相同。

快照其实是当前行数据之前的历史版本，每行记录可能有多个版本，如图显示，一个行记录可能有不止一个快照数据，一般称这种技术为多版本技术，由此带来的并发控制，称为多版本并发控制(Multi Version Concurrency Control,[MVCC](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html))

在事务隔离级别**RC**和**RR**下，`Innodb`存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。在**RC**事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在**RR**事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。

### 一致性读定锁

某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这就要求数据库支持加锁语句，即使是对于**SELECT**的只读操作，`Innodb`存储引擎对于**SELECT**语句支持两种一致性的锁定读(locking read)操作：
- SELECT...FOR UPDATE         (X锁)
- SELECT...LOCK IN SHARE MODE (S锁)

`SELECT...FOR UPDATE`对读取的行记录加上一个`X锁`，其他事务不能对已锁定的行加上任务锁。`SELECT...LOCK IN SHARE MODE`对读取的行记录加上一个`S锁`，其他事务可以向被锁定的行加`S锁`，但是如果加`X锁`，则会被阻塞。

对于一致性非锁定读，即使读取的行已被执行了`SELECT...FOR UPDATE`，也是可以进行读取的，这是因为**MVCC**。此外，`SELECT...FOR UPDATE`，`SELECT...LOCK IN SHARE MODE`必须在一个事务中，当事务提交了，锁也就释放了。因此在使用上诉两句**SELECT**锁定语句时，务必加上**BEGIN**,**START TRANSACTION**或者**SET AUTOCOMMIT=0**。

## 锁的算法

Innodb存储引擎行锁有3中行锁的算法，其分别是：
- Record Lock: 单个行记录上的锁
- Gap Lock: 间隙锁，锁定一个范围，但不包括记录本身
- Next-Key Lock : Gap Lock+Record Lock ，锁定一个范围，并且锁定记录本身

## 总结

学习数据库锁时，在锁的分类中，不同分类方式锁所表示的含义是不一样的，不能混淆，比如，不能将行锁与共享锁做比较，不然会陷入死胡同，这是两种不同的概念。

锁的分类 | 相关的锁
---|---
锁模式分类 | 乐观锁、悲观锁
范围锁 | 行锁、表锁
属性锁 | 共享锁(S)、排他锁(X)
状态锁 | 意向共享锁(IS)、意向排他锁(IX)
算法锁 | 记录锁、间隙锁、Next-Key Lock