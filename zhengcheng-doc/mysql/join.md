# MySQL JOIN详解与优化

## 一、MySQL JOIN 执行流程

1. 查询解析与优化：
   - MySQL解析查询语句，生成解析树。
   - 优化器根据解析树选择最佳的执行计划，包括表的读取顺序、JOIN类型、索引使用等。
2. 驱动表选择：
   - MySQL的优化器会选择一个表作为“驱动表”（或称为“基础表”），通常是数据量较小或者能够快速过滤的表。
   - 如果使用了`STRAIGHT_JOIN`，则强制指定左表为驱动表。
3. 索引评估：
   - 如果`JOIN`条件涉及索引，优化器会考虑使用这些索引来加速JOIN操作。
   - 对于`Nested-Loop Join`，索引可以用来快速定位匹配的行。
4. JOIN操作：
   - Nested-Loop Join(**NLJ**):
     - 从驱动表中取出一行，然后对每个匹配项在下一个表中进行查找，形成结果。
     - 如果使用了索引，这个过程可能会更快，因为可以快速定位到相关行。
   - Block Nested-Loop Join (BNL):
     - 适用于大数据量的情况，一次读取驱动表的多行（一个“块”），然后在另一个表上进行查找。
   - Hash Join:
     - MySQL 8.0引入了Hash Join，适用于较大的表。它创建一个驱动表的哈希索引，然后用这个索引匹配第二个表的行。
5. 结果集构建：
   - 每次找到匹配的行组合，就将它们添加到结果集中。
   - 如果有多个JOIN条件，这个过程**可能会递归进行**，直到所有表都`JOIN`完毕。
6. 排序与分组：
   - 如果查询中包含了ORDER BY或GROUP BY，MySQL会在JOIN之后进行额外的排序和分组操作。

## 二、MySQL JOIN 算法分析

### 2.1、嵌套循环连接 (Index Nested-Loop Join)

#### 2.1.1 关联查询的执行流程如下：
1. 先遍历关联表`t1`（驱动表，全表扫描）
2. 然后根据从表`t1`中取出的每行数据中的a值，去表`t2`（被关联表，被驱动表）中查找满足条件的记录
3. 可以走`t2`的索引搜索到满足条件的行字段， 跟上面的数据行组成一行；
4. 重复执行步骤`1`到`3`， 直到表`t1`的末尾循环结束。

在形式上，这个过程跟我们写程序时的嵌套查询类似。

#### 2.1.2 时间复杂度

假设被驱动表的行数是`M`。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是`以2为底的M的对数`，记为`log2M`，所以在被驱动表上查一行的时间复杂度是 `2*log2M`。

假设驱动表的行数是`N`，执行过程就要扫描驱动表`N`行，然后对于每一行，到被驱动表上匹配一次。 

因此整个执行过程，近似复杂度是 `N + N2log2M`。显然，`N`对扫描行数的影响更大，因此应该让小表来做驱动表：`N`扩大1000倍的话，扫描行数就会扩大1000倍；而`M`扩大1000倍，扫描行数扩大不到10倍。

#### 2.1.3 优化算法

**小表驱动大表**：为了优化Nested-Loop Join的性能，尽可能减少 Join 语句中的 Nested Loop 的循环总次数，就是让驱动表的结果集尽可能的小。对于很多表的关联通过应用层拆分成多个语句然后再拼接查询结果更方便， 而且性能也不会差。

在join的时候明确知道哪张表是小表的时候,可以用`straight_join`写法固定连接驱动方式

### 2.2、Block Nested-Loop Join 算法

#### 2.2.1 关联查询的执行流程

如果，被驱动表的关联字段没有使用索引，那么MySQL将使用另一种`Block Nested-Loop Join`算法。

1. 把表`t1`的数据读入线程内存join_buffer中，这只会将查询需要返回的列放入，如果我们的语句中写的是`select *`，就会把整个表`t1`放入了内存；
2. 扫描表`t2`，把表`t2`中的每一行取出来，跟`join_buffer`中的数据做对比，满足`join`条件的，作为结果集的一部分返回。
3. `join_buffer` 的大小是由参数`join_buffer_size`设定的(`show variables like '%join_buffer_size%';`)， 默认值是256k。

#### 2.2.2 时间复杂度

可以看到，在这个过程中， 对表`t1`和`t2`都做了一次全表扫描。 因此它的时间复杂度为：`O(M+N)`。由于`join_buffer`是以无序数组的方式组织的， 因此对表`t2`中的每一行， 都要做判断。
假设小表的行数是`N`， 大表的行数是`M`， 那么在这个算法里：
- 两个表都做一次全表扫描， 所以总的扫描行数是`M+N`；
- 内存中的判断次数是`M∗N`。

`Block Nested-Loop Join(BNL)`是一种优化的NLJ算法，`BNL` 通过将一个表分成多个块（`block`），然后逐个块与另一个表进行`Join`操作，从而减少了不必要的重复扫描和比较。
它可以提高`NLJ`在处理大数据集时的性能,但是会占用过多的`CPU资源`。会多次扫描被驱动表，占用磁盘IO资源。

#### 2.2.3 优化算法

- 给被驱动表的`join`字段加上索引，**把`BNL`算法转成`NLJ`算法**。
- 无法设置索引的情况可以通过设置`join_buffer_size`参数来控制`Join Buffer`的大小，以减少分段查询次数。

### 2.3、Hash Join 算法

::: tip 从 MySQL 8.0.20 开始，删除 BNL 算法，使用 Hash Join 算法替代。
> [Beginning with MySQL 8.0.20, support for block nested loop is removed, and the server employs a hash join wherever a block nested loop would have been used previously.](https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html)
:::

#### 2.3.1 执行流程

通常，我们认为，`Hash Join`分为两个阶段: `build` 构建阶段和 `probe` 探测阶段。

1. 初始化与资源分配
   - 内存分配：MySQL根据操作的预期规模，为构建哈希表分配内存。如果数据太大无法完全放入内存，将会使用`On-Disk`或`Grace Hash Join`策略。
   - 确定`JOIN`键：识别JOIN条件中用于构建哈希表的列。
2. **构建哈希表(build)**
   - 选择**构建表**：优化器决定哪个表用于构建哈希表。通常，较小的表或JOIN条件左侧的表是首选。
   - 读取与哈希：逐行读取构建表的数据，将JOIN键通过哈希函数转换为哈希码，然后根据哈希码存储到哈希表中。此过程可能需要多次迭代，如果数据量超过内存限制，则部分数据会被暂时写入磁盘。
3. **探测阶段(probe)**
   - 选择**探测表**：未被选为构建表的表成为探测表。
   - 逐行探测：遍历探测表的每一行，对JOIN键执行相同的哈希函数，查找对应的哈希表条目。
   - 匹配与结果组合：对于探测表的每一行，如果在哈希表中找到匹配项，则组合两表的相关数据形成结果集的行。
4. 处理溢出（如有）
   - On-Disk Hash Join：如果哈希表过大，部分数据会被写入磁盘。此时，探测阶段需要同时访问内存中的哈希表和磁盘上的溢出数据。
   - Grace Hash Join：一种更高效的磁盘溢出处理方式，通过增加哈希表的“桶”数来减少磁盘I/O，即使在磁盘上也能保持较好的性能。
5. 循环与清理
   - 对于大型数据集，构建和探测过程可能需要多次循环执行，每次循环针对哈希表未处理的部分数据。每次循环结束后，可能会清空或重置哈希表，以便处理下一组数据。
6. 结果集生成与返回
   - 组合所有匹配的结果行，根据查询需求进行排序（如果有ORDER BY子句）、分页（如果有LIMIT子句）等处理，最后将结果集返回给客户端。
   - 请注意，实际执行流程可能因MySQL的具体版本、配置参数以及查询的具体情况而有所差异。使用`EXPLAIN FORMAT=TREE`可以查看特定查询的执行计划，以了解MySQL实际选择的JOIN算法及其详细步骤。

#### 2.3.2 时间复杂度

理想情况下，不考虑冲突和磁盘I/O，Hash Join的时间复杂度是`O(m + n)`。然而，由于磁盘I/O和哈希冲突的存在，实际时间复杂度可能更高，尤其是在数据量大且内存有限的情况下。

#### 2.3.3 优化算法

1. 当哈希表所需的内存量超过`join_buffer_size`大小，会使用磁盘的文件进行处理，所以增加`join_buffer_size`值避免生成文件可以极大提升查询速度。
2. 优化的哈希表设计（如开放地址法或链地址法）和良好的哈希函数选择可以降低冲突概率。

