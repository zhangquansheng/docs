# 模板模式

在模板模式（`Template Pattern`）中，一个抽象类公开定义了执行它的方法的方式/模板。
它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于**行为型模式**。

它的主要意图是定义一个操作中的**算法的骨架**，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

注意事项：一般的为防止恶意操作，一般模板方法都加上`final`关键词。但在`Spring`项目中，对象为实现接口的，会使用`Cglib`，因为`final`的方法不能被继承，所以不要使用`final`。
> `CGLIB`动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。

## 抽象类中使用 @Autowired

- **因为抽象类就是要被继承的，所以抽象类不能增加`final`修饰**。 
- 抽象类不会进行组件扫描，因为没有具体的子类就无法实例化。
- `Spring`在抽象类中不支持构造函数注入。
- 私有字段就像其他任何非静态字段一样被[继承](https://www.runoob.com/java/java-inheritance.html)，它们只是在子类代码中不可见，`Spring`将自动装配这些字段。

--- 

参考文档
- [模板模式|菜鸟教程](https://www.runoob.com/design-pattern/template-pattern.html)