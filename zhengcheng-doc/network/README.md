# 概述

## TCP三次握手 :+1:

![tcp-shakes-hands-three-times](/img/network/tcp-shakes-hands-three-times.png)

1. 第一次握手

客户端向服务端发送连接请求报文段。该报文段的头部中同步SYN=1，确认ACK=0，同时选择一个初始序号seq=x。请求发送后，客户端便进入**SYN_SENT**状态。

- SYN=1，ACK=0表示该报文段为连接请求报文
- x为本次TCP通信的字节流的初始序号
- TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号

2. 第二次握手

服务端收到连接请求报文段后，如果同意连接，会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。发送完应答后服务端进入**SYN_RECV**状态。

- SYN=1，ACK=1表示该报文段为连接同意的应答报文
- seq=y表示服务端作为发送者时，发送字节流中的第一个字节序号
- ack=x+1表示服务端希望客户端发送的下一个数据报初始序号是从x+1开始

3. 第三次握手

客户端收到服务端连接同意的应答后，还会向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。

客户端发完这个报文段后便进入`ESTABLISHED`状态，服务端收到这个应答后也进入`ESTABLISHED`状态（TCP连接成功），此时连接的建立完成！

三次握手的目的是**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**。

### 为什么不是两次握手？

**是为了防止已失效的连接请求报文段突然又传送到了服务端，造成服务端资源的浪费。**

> 在一次TCP连接中，客户端A向服务端B发送连接请求SYN报文段，假如这个报文段没有及时被服务端B接收，而是滞留在网络的某处，于是客户端A超时重传，再次发送请求连接并且顺利与服务端B建立了连接，交换数据后断开连接。

> 那么滞留在网络中的某处的陈旧报文就变成了失效的连接请求报文。

> 但如果这个失效的请求SYN报文段，现在又突然传送到了服务端B处，设想这时是使用两次握手而不是三次握手，服务端B就以为客户端A现在建立请求连接，于是服务端B发出确认，新的连接就建立了，服务端B分配资源，等待客户端A传送数据，但客户端A并没有想要建立TCP连接，不会理会服务端B发送的应答，也不会向服务端B传送数据，于是服务端B就白白等待，空耗资源。

> 使用三次握手可以避免这个情况：服务端B收到客户端A的失效的陈旧SYN报文段，向客户端A发送SYN报文段，选择自己的序号seq=y，确认收到客户端A的SYN报文段，确认号ack=x+1。第三次握手客户端A收到服务器B的SYN报文段后，从确认号就可得知不应理睬这个SYN报文段（因为客户端A现在并没有发送seq=x的报文段）。

> 这时，客户端A会发送复位报文段，这个复位报文段中，RST=1，ACK=1，确认号ack=y+1。

> 服务端B收到客户端A的复位报文，就知道不建立TCP连接，不会分配资源等待客户端A发送数据。

> ![tcp-shakes-hands-two-times](/img/network/tcp-shakes-hands-two-times.png)

### 为什么不是四次握手？

因为三次握手已经能说明握手时的通信是正常的，四次握手、五次握手就显得浪费了。

## 四次挥手 :+1:

- **第一次挥手** ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。
- **第二次挥手** ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。然后，此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。
- **第三次挥手** ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入LAST-ACK状态。
- **第四次挥手** ：客户端发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入TIME-WAIT状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。

### 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

> MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

## TCP粘包、拆包 :+1:

`TCP`是面向流，没有界限的一串数据。`TCP`底层并不了解上层业务数据的具体含义，它会根据`TCP`缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被`TCP`拆分成多个包进行发送，也有可能把多个小
的包封装成一个大的数据包发送，这就是所谓的`TCP`粘包和拆包问题。

### 为什么会产生粘包和拆包

1. 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；
2. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
3. 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；
4. 待发送数据大于 MSS (最大报文长度),TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度>MSS

### 解决策略

1. 发送端将每个数据包封装为固定长度;
2. 在数据尾部增加特殊字符进行分割;
3. 将数据分为两部分，一部分是头部,一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。