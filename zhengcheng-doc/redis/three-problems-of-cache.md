# 缓存三大问题之缓存穿透、缓存击穿、缓存雪崩及其解决方案

## 缓存穿透

**缓存穿透**: 大量请求的`key`根本不存在于缓存中，导致请求直接到了数据库上。

### 解决方案

- 缓存空值/空值缓存: 一种比较简单的解决办法，在第一次查询完不存在的数据后，将该`key`与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，
这样则可以应对短时间的大量的该`key`（重复`KEY`）攻击，设置为较短的失效时间则是因为该值可能跟业务无关，存在意义不大，且该次的查询也未必是攻击者发起，
没有长期存储的必要，故可以早点失效。

- BloomFilter(布隆过滤器): 特点是**肯定不存在，可能存在**，所以可以把所有可能的查询条件生成一个`bitmap`，在进行数据库查询之前会使用这个`bitmap`进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。

## 缓存击穿 

**缓存击穿**: 大量的请求同时查询一个`key`时，此时这个`key`正好失效，就会导致大量的请求都打到数据库上面去。（**缓存击穿**实际上是缓存雪崩的一个特例，是**热点KEY失效问题**）

### 解决方案

- 分布式锁: 

## 缓存雪崩

**缓存雪崩**: 当某一时刻发生大规模的缓存失效的情况，例如缓存同一时刻过期、存服务宕机等

### 解决方案

- 设置不同的过期时间：在基础时间添加/减去一个随机数，以错开这些缓存的过期时间。
- 本地缓存 + Hystrix限流&降级,避免MySQL被打死
