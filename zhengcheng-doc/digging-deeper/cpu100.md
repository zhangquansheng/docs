# 线上服务 CPU 100% 的处理过程 

CPU是整个电脑的核心计算资源，对于一个应用进程来说，CPU的最小执行单元是**线程**。

## 原因

- 一、CPU上下文切换过多：于CPU来说，同一时刻下每个CPU核心只能运行一个线程，如果有多个线程要执行，CPU只能通过上下文切换的方式来执行不同的线程。上下文切换需要做两个事情
  1. 保存运行线程的执行状态
  2. 让处于等待中的线程执行
- 二、CPU资源过度消耗：也就是在程序中创建了大量的线程，或者有线程一直占用CPU资源无法被释放，比如**死循环**！

## 解决步骤

top 定位进程ID -> top -Hp 定位线程ID ->  线程ID转成16进制 -> jstack获取线程的Dump日志

1. 执行`top`命令查看，定位到占用`CPU`高的进程`ID`，按一下`P`可以按照`CPU`使用率进行排序
```shell script
top -c
```

2. 使用 `top -Hp <进程ID>` 定位到占用`CPU`高的线程`ID`，继续按`P`排序
```shell script
top -Hp <进程ID>
```

3. 将线程`ID`转换成为16进制，为后面查找`jstack`日志做准备
```shell script
printf "0x%x" 线程PID
```

4. `jstack` 进程`PID` | vim +/`十六进制线程PID` 
> 通过jstack获得线程的Dump日志

5. 最后有可能定位的结果是程序正常，只是在CPU飙高的那一刻，用户访问量较大，导致系统资源不够。

## CPU 上下文切换

**CPU寄存器**和**程序计数器**是 CPU上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。
- CPU 寄存器： CPU 内置的容量小、但速度极快的内存。
- 程序计数器则：用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

CPU 上下文切换就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，运行新任务。

而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

## CPU 线程调度 :hammer:

## 实战一：正则表达式回溯造成 CPU 100%
