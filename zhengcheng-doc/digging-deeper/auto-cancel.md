# 生成订单30分钟未支付，则自动取消，该怎么实现？

在开发中，往往会遇到一些关于延时任务的需求。例如
- 生成订单`30`分钟未支付，则自动取消
- 生成订单`60`秒后,给用户发短信

对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别
- 定时任务有明确的触发时间，延时任务没有
- 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期
- 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务

## 数据库轮询 :+1:

> 数据量，并发量并不大的系统，可以使用这个方案。

该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行`update`或`delete`等操作。

- 优点: 简单易行，支持集群操作
- 缺点:
  - (1)对服务器内存消耗大
  - (2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是`3`分钟
  - (3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大

## JDK的延迟队列 :speak_no_evil:

该方案是利用`JDK`自带的`DelayQueue`来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入`DelayQueue`中的对象，是必须实现`Delayed`接口的。

- 优点: 效率高,任务触发时间延迟低。
  - 缺点:
  - (1)服务器重启后，数据全部消失，怕宕机 
  - (2)集群扩展相当麻烦 
  - (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常
  - (4)代码复杂度较高

## 时间轮算法 :speak_no_evil:

## redis缓存 :speak_no_evil:

## 消息队列 :+1:

- 优点: 高效,可以利用消息队列的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。
- 缺点：依赖消息队列，复杂度和成本变高

### RocketMQ 实现

### Kafka 实现