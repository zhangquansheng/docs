# 深入理解IO模型 :hammer:

首先我们知道，操作系统为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为：**用户空间（User space）** 和**内核空间（Kernel space ）** 。

我们在平常开发过程中接触最多的就是**磁盘 IO（读写文件）**和**网络 IO（网络请求和相应）。**

从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起`IO`调用（系统调用），操作系统负责的内核执行具体的`IO`操作。
也就是说，我们的应用程序实际上只是发起了`IO`操作的调用而已，具体`IO`的执行是由操作系统的内核来完成的。

当应用程序发起`I/O` 调用后，会经历两个步骤：
1. 内核（Kernel）等待`I/O`设备准备好数据
2. 内核（Kernel）将数据从内核空间拷贝到用户空间。

`Java` 中`3`种常见`IO`模型：`BIO`、`NIO`、`I/O多路复用`。

首先我们需要知道，`java`其实是一种解释型语言，通过`JVM`虚拟机将我们的`.java`文件转换为**字节码文件**，然后调用我们`os`中的`syscall`方法，
我们必须明确的是，无论怎么调用，一定最后要通过**调用内核的方法**，然后调用我们的硬件。

## BIO

同步阻塞`IO`模型中，应用程序发起`read`调用后，会一直**阻塞**，直到内核把数据拷贝到用户空间。为了同时相应多个并发的请求，必须实现多线程。
每个线程处理一个请求，线程数随着并发连接数线性增长。

## NIO

同步非阻塞`IO`模型。`NIO`中客户端和服务器之间通过`Channel`通信。这些`Channel`都会被注册在`Selector`多路复用选择器上。
`Selector`通过一个线程不停的轮询这些`Channel`，找出已经准备就绪的`Channel`执行`IO`操作（`C10K问题`）。

简单来说，`NIO`通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞`NIO`的特点。

## I/O多路复用

`NIO`每次都需啊哟遍历所有的客户端（`C10K`），是非常耗时的，其实很多的客户端可能就没有发送请求。`I/O多路复用模型`下是不需要这样的，
而是把我们的`fds`文件发送给内核，然后内核根据多路复用器`select`去判断最后需要连接的客户端。

> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
>  - `select`调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
>  - `epoll`调用 ：`linux 2.6` 内核，属于`select`调用的增强版本，优化了`IO`的执行效率。

## AIO

异步`IO`是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。