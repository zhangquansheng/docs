# 40亿个QQ号码如何去重？

采用`bitmap`这种数据结构，可以顺利地同时解决时间问题和空间问题。

在很多实际项目中，`bitmap`经常用到。我看了不少组件的源码，发现很多地方都有`bitmap`实现，`bitmap`图解如下：

![bitmap-1](/img/digging-deeper/bitmap-1.webp)

这是一个`unsigned char`类型，可以看到，共有`8`位，取值范围是`[0, 255]`，如上这个`unsigned char`的值是`255`，它能标识`0~7`这些数字都存在。

同理，如下这个`unsigned char`类型的值是`254`，它对应的含义是：`1~7`这些数字存在，而数字`0`不存在：

![bitmap-1](/img/digging-deeper/bitmap-1.webp)

由此可见，一个`unsigned char`类型的数据，可以标识`0~7`这`8`个整数的存在与否。以此类推：
- 一个`unsigned int`类型数据可以标识`0~31`这`32`个整数的存在与否。
- 两个`unsigned int`类型数据可以标识`0~63`这`64`个整数的存在与否。

显然，可以推导出来：`512MB`大小足够标识所有`QQ`号码的存在与否，请注意：`QQ`号码的理论最大值为`2^32 - 1`，大概是`43`亿左右。

接下来的问题就很简单了：用`512MB`的`unsigned int`数组来记录文件中`QQ`号码的存在与否，形成一个`bitmap`，比如：
```properties
bitmapFlag[123] = 1
bitmapFlag[567] = 1
bitmapFlag[123] = 1
bitmapFlag[890] = 1
```
实际上就是：
```properties
bitmapFlag[123] = 1
bitmapFlag[567] = 1
bitmapFlag[890] = 1
```
然后从小到大遍历所有正整数(`4字节`)，当`bitmapFlag`值为`1`时，就表明该数是存在的。

## 扩展练习一

### 文件中有40亿个互不相同的QQ号码，请设计算法对QQ号码进行排序，内存限制1G.

很显然，直接用`bitmap`, 标记这`40亿`个`QQ`号码的存在性，然后从小到大遍历正整数，当`bitmapFlag`的值为`1`时，就输出该值，输出后的正整数序列就是排序后的结果。

请注意，这里必须限制`40亿`个`QQ`号码互不相同。通过`bitmap`记录，客观上就自动完成了排序功能。

## 扩展练习二

### 文件中有40亿个互不相同的QQ号码，求这些QQ号码的中位数，内存限制1G.

我知道，一些刷题经验丰富的人，最开始想到的肯定是用堆或者文件切割，这明显是犯了本本主义错误。直接用`bitmap`排序，当场搞定中位数。

## 扩展练习三

### 文件中有`40亿`个互不相同的QQ号码，求这些QQ号码的top-K，内存限制1G.

我知道，很多人背诵过`top-K`问题，信心满满，想到用小顶堆或者文件切割，这明显又是犯了本本主义错误。直接用`bitmap`排序，当场搞定`top-K`问题。

## 扩展练习四

### 文件中有80亿个QQ号码，试判断其中是否存在相同的QQ号码，内存限制1G.

我知道，一些吸取了经验教训的人肯定说，直接`bitmap`啊。然而，又一次错了。根据容斥原理可知：
因为`QQ`号码的个数是`43亿`左右(理论值`2^32 - 1`)，所以`80`亿个`QQ`号码必然存在相同的`QQ`号码。
