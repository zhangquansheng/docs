# 经典排序算法

## 概述

[动图演示](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

::: tip 什么是稳定排序?
待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i<j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。比如int数组[1,1,1,6,4]中a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。

稳定排序算法有：插入排序，基数排序，归并排序，冒泡排序，计数排序。

不稳定排序算法有：快速排序，希尔排序，简单选择排序，堆排序。
:::

算法复杂度对比图:
![sort-overview](/img/algorithms/sort-overview.png)

## 冒泡排序（Bubble Sort）

冒泡排序就是把**小的元素往前调**或者把**大的元素往后调**。比较是相邻的两个元素比较，交换也发生在这两个元素之间。

排序流程如下： 
1. 比较**相邻的元素**。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1] 
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 


## 选择排序（Selection Sort）

首先在未排序序列中**选择最小（大）元素**，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续选择最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

排序流程如下：
1. 初始状态：无序区为R[0..n-1]（共n个元素），有序区为空。
2. 第1趟排序
   
    设置一个变量i，让i从0至n-2循环的同时，在对比数组中元素i跟元素i+1的大小，如果R[i+1]比R[i]小，则用一个变量k来记住他的位置（即k=i+1）。等到循环结束的时候，我们应该找到了R中最小的那个数的位置了。然后进行判断，如果这个最小元素的不是R的第一个元素，就让第一个元素跟他交换一下值，使R[0..0]和R[1..n-1]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 
……

3. 第i趟排序

    第i趟排序开始时，当前有序区和无序区分别为R[0..i-1]和R[i..n-1]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[0..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。


**交换次数比冒泡排序少多了，由于交换所需CPU时间比**比较**所需的CPU时间多，**n值较小时，选择排序比冒泡排序快**。

## 插入排序（Insertion Sort）

插入排序是一种最简单的排序方法，它的基本思想是将**一个记录插入到已经排好序的有序表中**，从而一个新的、记录数增1的有序表。

## 希尔排序（Shell Sort）

希尔排序是插入排序的一种又称“**缩小增量排序**”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

其排序流程如下：
1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

## 快速排序（Quick Sort）

它的基本思想是：**通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小**，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序算法通过多次**比较**和**交换**来实现排序，其排序流程如下：
1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。
2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 
3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

## 归并排序（Merge Sort）

归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用**分治法**（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

归并排序流程如下：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾

归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。速度仅次于快速排序，为稳定排序算法。

